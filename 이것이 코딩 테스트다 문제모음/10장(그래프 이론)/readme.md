# 10장

그래프 : 인접행렬 혹은 인접리스트로 표현하기.

탐색 알고리즘
1. DFS : stack. index가 작은쪽부터 쭉 탐색하고 올라오기
2. BFS : q -> import deque.

탐색 중 최단 경로 알고리즘
1. 다익스트라 : 우선순위 q -> import heapq (distance, node_index) 순서로 집어넣기.
- i 노드에서 j노드로 가는 경우 : dp_table[i] + distance < dp_table[j] 시 update.
2. 플로이드 워셜 알고리즘 : 3중 for문. k,i,j 순서로 짜기.
- i 노드에서 k노드를 거쳐 j노드로 가는 경우 : dp_table[i][j] = min(dp_table[i][j], dp_table[i][k] + dp_table[k][j])

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

빈도는 적지만 배워야할 알고리즘
1. 크루스칼 알고리즘
2. 위상 정렬 알고리즘

## 서로소 집합 개념
- 공통 원소가 없는 두 집합 : (1,2) 와 (3,4) | (1,2) 와 (2,3) 은 서로소 집합ㅇ ㅣ아님.

서로소 집합 자료구조 : 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조.
- union과 find 두 개의 연산으로 조작.

알고리즘
1. union 연산 : 번호 작은 노드가 부모가 되도록. 자식이 부모를 가르키는 edge형성
2. 모든 union 연산 처리.
**이때 시간복잡도를 위해 경로압축 기법 사용**

신장 트리 : 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프
최소 신장 트리 : 최소 비용으로 만들 수 있는 신장 트리.

즉 그래프에서 최단경로보다는 모든 점을 최소 비용으로 이을때 고려할 알고리즘.

## 크루스칼 알고리즘
1. edge 크기에 따라 오름차순 정렬
2. 사이클을 형성하지 않는다면 edge 등록.
3. 모든 edge에 대해 반복(최대 edge 수는 node수-1)
