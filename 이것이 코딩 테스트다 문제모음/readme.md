가장 난이도 낮은 문제 : 구현, 그리디 알고리즘 -> 합격을 좌우한다. 꼭 해결해야함.  
11-6 무지 먹방 다시풀기  
12-4 자물쇠와 열쇠 다시풀기  
- def rotation(matrix) 암기.

12-6 기둥과 보 설치 다시풀기
- def check_available 잘 했음.

12-8 외벽 점검 다시풀기
- 원형으로 나열된 데이터를 처리하는 경우 길이를 2배로 늘려서 원형을 일자 형태로 만들기.

13-4 연산자 끼워 넣기
- 메모리 초과. dfs로 다시 풀기

13-8 블록 이동하기 다시 풀기
- 예제만 맞춤.

14-2 안테나 다시 풀기
- 간단함. 수학적 사고 요구

14-4 카드정렬 다시 풀기
- 예제는 통과. 시간초과임. 자료구조(정렬)에 대한 이해 필요

# 1장
1. 시간복잡도 : 데이터 개수(N), 시간제한 1초
   1. N < 500 : O(N***3)
   2. N < 2000 : O(N**2)
   3. N < 100,000 : O(N logN )
   4. N < 10,000,000 : O(N)

2. 공간 복잡도 : 리스트 내의 데이터 개수는 1,000만 단위 이내.

   **공간복잡도는 대부분 python에서 고려 안해도됨**


# 2장
기술 면접 : 알고리즘 문제 풀이, 질의응답, 포트폴리오 질의응답, 컴퓨터공학 지식 질의응답
- 시간복잡도에 대한 설명. 단순히 높다 낮다 x. 서로 다른 알고리즘을 비교하여 '특정한 상황'에서 무엇이 더 좋을지 설명 가능해야함.


# 3장(Greedy)
- 암기 x
- 특정한 문제를 만났을 때 단순히 현재 상황에서 가장 좋아 보이는 것만을 선택해서 문제를 풀 수 있는지 파악 -> '가장 큰 순서대로', '가장 작은 순서대로'
- 주로 정렬 알고리즘과 짝을 이뤄 출제된다.
- 대표 문제 : 거스름돈
## 그리디와 같이 탐욕적으로 풀지 못하는 경우 -> 다이나믹 프로그래밍, 그래프 알고리즘으로 고민


# 4장(구현)
문제 풀이는 쉽게 떠올리지만 코드로 옮기기 어려운 문제.  
'피지컬'을 요구하는 문제. 언어의 문법, 라이브러리 활용도를 요구. 따라서 많이 해보는게 답.  

1. 완전탐색
2. 시뮬레이션 

## 리스트 개수가 1000만 이상인 리스트가 있다면 용량 제한을 걱정해볼 것.
- 별로 안나온다. 그냥 틀리자

## 표준 : 시간 제한 1초, 메모리 제한 128MB
- 1초에 2,000만 번의 연산이면 적절.
- if 데이터 개수가 100만개(not 1000만개)라면 시간 복잡도 O(N logN) 알고리즘 사용.
- 추후에 알고리즘 별 시간 복잡도 암기할 것.

## 보통 문제 길이가 길다. 겁먹지 말 것. 사고력 x. 차근차근 구현해나가면 됨.

# 5장(DFS/BFS)

그래프, 트리 등 자료구조 안에서 탐색하는 문제.  
대표적인 탐색 알고리즘 : DFS, BFS

**자료구조란?**
- 데이터를 표현하고 관리하고 처리하기 위한 구조.
- 스택과 큐 는 자료구조의 기초 개념.

1. 스택, 큐
- 삽입, 삭제
- 오버플로(저장 공간이 가득 찼을 때 삽입 연산을 수행하는 경우), 언더플로(데이터가 없는 상태에서 삭제 연산을 수행하는 경우)

# 6장(정렬)

1. 선택 정렬 : i번째 시점에서 i번째 이후 숫자 중 매번 가장 작은 것을 선택하여 i 위치에 배치
- N개 원소에 대하여 N-1, N-2, ... 1번 탐색해야함.
- 따라서 O(N**2)
2. 삽입 정렬 : 특정 데이터가 적절한 위치에 들어가기 전에 이미 그 앞까지는 데이터가 정렬되어있다고 가정.
- 그 앞까지에 대해서만 탐색. 맨 앞부터 탐색하다가 본인보다 큰 수를 만나면 그 자리에 삽입.
- 최악의 경우 O(N**2), 최선의 경우 O(N)이 될 수 있음.
- 데이터가 어느정도 정렬되어 있는 경우 삽입정렬 사용
3. 퀵 정렬 : pivot(기준값) 보다 작은 배열, 큰 배열로 split 후 가운데 pivot값 배치. 재귀적으로 반복
- 최악의 경우 O(N**2), 최선의 경우 1/2씩 감소. 따라서 O(N*log N)
- 데이터가 무작위로 입력되는 경우 퀵 정렬 사용
4. 계수 정렬 : '데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때'만 사용 가능
- N개의 크기 리스트를 생성(index가 곧 값을 의미), 리스트의 값은 i가 몇번 나타났는지를 의미.
- i번째 값이 value만큼 이어서 출력하면 완성.
- 시간복잡도 O(N+K)
