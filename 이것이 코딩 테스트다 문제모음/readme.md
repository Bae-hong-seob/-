가장 난이도 낮은 문제 : 구현, 그리디 알고리즘 -> 합격을 좌우한다. 꼭 해결해야함.  
11-6 무지 먹방 다시풀기  
12-4 자물쇠와 열쇠 다시풀기  
- def rotation(matrix) 암기.

12-6 기둥과 보 설치 다시풀기
- def check_available 잘 했음. 

# 1장
1. 시간복잡도 : 데이터 개수(N), 시간제한 1초
   1. N < 500 : O(N***3)
   2. N < 2000 : O(N**2)
   3. N < 100,000 : O(N logN )
   4. N < 10,000,000 : O(N)

2. 공간 복잡도 : 리스트 내의 데이터 개수는 1,000만 단위 이내.

   **공간복잡도는 대부분 python에서 고려 안해도됨**


# 2장
기술 면접 : 알고리즘 문제 풀이, 질의응답, 포트폴리오 질의응답, 컴퓨터공학 지식 질의응답
- 시간복잡도에 대한 설명. 단순히 높다 낮다 x. 서로 다른 알고리즘을 비교하여 '특정한 상황'에서 무엇이 더 좋을지 설명 가능해야함.


# 3장(Greedy)
- 암기 x
- 특정한 문제를 만났을 때 단순히 현재 상황에서 가장 좋아 보이는 것만을 선택해서 문제를 풀 수 있는지 파악 -> '가장 큰 순서대로', '가장 작은 순서대로'
- 주로 정렬 알고리즘과 짝을 이뤄 출제된다.
- 대표 문제 : 거스름돈
## 그리디와 같이 탐욕적으로 풀지 못하는 경우 -> 다이나믹 프로그래밍, 그래프 알고리즘으로 고민


# 4장(구현)
문제 풀이는 쉽게 떠올리지만 코드로 옮기기 어려운 문제.  
'피지컬'을 요구하는 문제. 언어의 문법, 라이브러리 활용도를 요구. 따라서 많이 해보는게 답.  

1. 완전탐색
2. 시뮬레이션 

## 리스트 개수가 1000만 이상인 리스트가 있다면 용량 제한을 걱정해볼 것.
- 별로 안나온다. 그냥 틀리자

## 표준 : 시간 제한 1초, 메모리 제한 128MB
- 1초에 2,000만 번의 연산이면 적절.
- if 데이터 개수가 100만개(not 1000만개)라면 시간 복잡도 O(N logN) 알고리즘 사용.
- 추후에 알고리즘 별 시간 복잡도 암기할 것.

## 보통 문제 길이가 길다. 겁먹지 말 것. 사고력 x. 차근차근 구현해나가면 됨.
