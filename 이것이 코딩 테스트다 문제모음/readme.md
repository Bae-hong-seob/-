가장 난이도 낮은 문제 : 구현, 그리디 알고리즘 -> 합격을 좌우한다. 꼭 해결해야함.  
11-6 무지 먹방 다시풀기  
12-4 자물쇠와 열쇠 다시풀기  
- def rotation(matrix) 암기.

12-6 기둥과 보 설치 다시풀기
- def check_available 잘 했음.

12-8 외벽 점검 다시풀기
- 원형으로 나열된 데이터를 처리하는 경우 길이를 2배로 늘려서 원형을 일자 형태로 만들기.

13-4 연산자 끼워 넣기
- 메모리 초과. dfs로 다시 풀기

13-8 블록 이동하기 다시 풀기
- 예제만 맞춤.

14-2 안테나 다시 풀기
- 간단함. 수학적 사고 요구

14-4 카드정렬 다시 풀기
- 예제는 통과. 시간초과임. 자료구조(정렬)에 대한 이해 필요

15-3 공유기 설치 다시 풀기
- gap을 이진탐색 mid로 생각하는 아이디어

15-4 가사 검색 다시풀기
- from bisect import bisect_left, bisect_right 기억

16-4 병사 배치하기 다시풀기
- 가장 긴 증가하는 부분 수열 : 전형적인 다이나믹 프로그래밍 문제 (LIS : Longest Increasing Subsequence)

# 1장
1. 시간복잡도 : 데이터 개수(N), 시간제한 1초
   1. N < 500 : O(N***3)
   2. N < 2000 : O(N**2)
   3. N < 100,000 : O(N logN )
   4. N < 10,000,000 : O(N)

2. 공간 복잡도 : 리스트 내의 데이터 개수는 1,000만 단위 이내.

   **공간복잡도는 대부분 python에서 고려 안해도됨**


# 2장
기술 면접 : 알고리즘 문제 풀이, 질의응답, 포트폴리오 질의응답, 컴퓨터공학 지식 질의응답
- 시간복잡도에 대한 설명. 단순히 높다 낮다 x. 서로 다른 알고리즘을 비교하여 '특정한 상황'에서 무엇이 더 좋을지 설명 가능해야함.


# 3장(Greedy)
- 암기 x
- 특정한 문제를 만났을 때 단순히 현재 상황에서 가장 좋아 보이는 것만을 선택해서 문제를 풀 수 있는지 파악 -> '가장 큰 순서대로', '가장 작은 순서대로'
- 주로 정렬 알고리즘과 짝을 이뤄 출제된다.
- 대표 문제 : 거스름돈
## 그리디와 같이 탐욕적으로 풀지 못하는 경우 -> 다이나믹 프로그래밍, 그래프 알고리즘으로 고민


# 4장(구현)
문제 풀이는 쉽게 떠올리지만 코드로 옮기기 어려운 문제.  
'피지컬'을 요구하는 문제. 언어의 문법, 라이브러리 활용도를 요구. 따라서 많이 해보는게 답.  

1. 완전탐색
2. 시뮬레이션 

## 리스트 개수가 1000만 이상인 리스트가 있다면 용량 제한을 걱정해볼 것.
- 별로 안나온다. 그냥 틀리자

## 표준 : 시간 제한 1초, 메모리 제한 128MB
- 1초에 2,000만 번의 연산이면 적절.
- if 데이터 개수가 100만개(not 1000만개)라면 시간 복잡도 O(N logN) 알고리즘 사용.
- 추후에 알고리즘 별 시간 복잡도 암기할 것.

## 보통 문제 길이가 길다. 겁먹지 말 것. 사고력 x. 차근차근 구현해나가면 됨.

# 5장(DFS/BFS)

5-10 다시풀기  

그래프, 트리 등 자료구조 안에서 탐색하는 문제.  
대표적인 탐색 알고리즘 : DFS, BFS

**자료구조란?**
- 데이터를 표현하고 관리하고 처리하기 위한 구조.
- 스택과 큐 는 자료구조의 기초 개념.

1. 스택, 큐
- 삽입, 삭제
- 오버플로(저장 공간이 가득 찼을 때 삽입 연산을 수행하는 경우), 언더플로(데이터가 없는 상태에서 삭제 연산을 수행하는 경우)

2. python 스택 : list [] 그냥 사용하면 됨.
- list.append(3)
- list.pop()

3. python 큐 : from collections import deque 기억.
- dq = deque() 기억.
- dq.pop(), dq.popleft()
- dq.append(), dq.appendleft()

4. 재귀함수 : 스택 자료구조를 이용. 수학으로 따지자면 점화식.
- 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 전의 함수 호출이 종료되기 때문에.
- 점화식이 중요한 이유 : 이후에 다이나믹 프로그래밍으로 이어짐.
- 대표적인 재귀함수 에제 : 팩토리얼
- 스택 자료구조를 활용해야하는 상당수 알고리즘은 재귀 함수를 이용해서 간편하게 구현될 수 있다. ex) DFS

## 기초개념 : 스택, 큐, 재귀함수

## 그래프(Graph) : 노드(node), 간선(Edge)로 이루어짐.
구현방식 1. 인접 행렬 : 2차원 배열로 그래프의 연결 관계(Edge)를 표현하는 방식  
구현방식 2. 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식


## DFS는 graph 인접리스트로 표현, 재귀함수, 스택을 활용한 탐색 알고리즘
## BFS는 graph 인접리스트로 표현, 큐를 활용한 탐색 알고리즘


## DFS(Depth-First Search) 시간복잡도 : O(N)
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
2. 스택의 최 상단 노드에 방문하지 않은 인접 노드가 있으면 해당 인접 노드를 스택에 삽입하고 방문 처리. 방문하지 않은 인접 노드가 없으면 스택에서 최 상단 노드를 삭제.
3. 1-2 단계를 더 이상 수행할 수 없을 때 까지 반복.

**방문 처리란 스택에 한번 삽입된 노드가 다시 삽입되지 않게 체크 처리 하는 것**
- 인접 리스트로 graph 표현 & 재귀함수 사용.
- 5-8 DFS 예제.py 확인

## BFS(Breath-First Search) 시간복잡도 : O(N)
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문 하지 않은 노드를 모두 큐에 삽입하고 방문 처리
3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복


# 6장(정렬)

1. 선택 정렬 : i번째 시점에서 i번째 이후 숫자 중 매번 가장 작은 것을 선택하여 i 위치에 배치
- N개 원소에 대하여 N-1, N-2, ... 1번 탐색해야함.
- 따라서 O(N**2)
2. 삽입 정렬 : 특정 데이터가 적절한 위치에 들어가기 전에 이미 그 앞까지는 데이터가 정렬되어있다고 가정.
- 그 앞까지에 대해서만 탐색. 맨 앞부터 탐색하다가 본인보다 큰 수를 만나면 그 자리에 삽입.
- 최악의 경우 O(N**2), 최선의 경우 O(N)이 될 수 있음.
- 데이터가 어느정도 정렬되어 있는 경우 삽입정렬 사용
3. 퀵 정렬 : pivot(기준값) 보다 작은 배열, 큰 배열로 split 후 가운데 pivot값 배치. 재귀적으로 반복
- 최악의 경우 O(N**2), 최선의 경우 1/2씩 감소. 따라서 O(N*log N)
- 데이터가 무작위로 입력되는 경우 퀵 정렬 사용
4. 계수 정렬 : '데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때'만 사용 가능
- N개의 크기 리스트를 생성(index가 곧 값을 의미), 리스트의 값은 i가 몇번 나타났는지를 의미.
- i번째 값이 value만큼 이어서 출력하면 완성.
- 시간복잡도 O(N+K)

# 7장(이진탐색)

1. 순차 탐색 : 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용.  
- 시간복잡도 최악의 경우 O(N)

2. 이진 탐색 : 데이터가 정렬되어 있을 때 사용.
- 시작과 끝점을 기준으로 중간점을 지정.
- target과 중간점 값을 확인한 후 target < 중간점 -> 끝점을 중간점으로 옮김. or target > 중간점 -> 시작점을 중간점으로 옮김.
- 중간점이 target 값과 동일할 때 까지.
- 시간복잡도 최악의 경우 O(log N)

## 데이터 탐색 개수가 1,000만 단위가 넘어간다면 O(log N)을 고려. 이진탐색 활용

# 8장(다이나믹 프로그래밍)
1. 다이나믹 프로그래밍(=동적 계획법) : 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법
- 대표적인 유형 : 점화식
- 대표적인 문제 : 피보나치 수열
- 대표적인 구현 : 재귀 함수!

2. **점화식을 재귀 함수로 구현할 수도 있지만 시간 복잡도가 개 미쳤음**
- 메모이제이션(=캐싱) 기법 사용 : 한번 구한 결과를 메모리 공간에 메모해두고, 같은 식을 다시 호출할 때 메모한 결과를 그대로 가져오는 기법
- 단순하다. 한번 구한 정보를 리스트에 저장해놓는 것.

3. 메모이제이션(=캐싱) 기법 시간 복잡도 : O(N)
- 메모리는 오버헤드 발생할수도

4. 메모이제이션 방식 : 탑다운, 다이나믹 프로그래밍은 보통 바텀업 방식으로 구현.

5. 다이나믹 프로그래밍(바텀업)
- 결과 저장용 리스트를 보통 DP 테이블이라고 지칭.
- 이때 DP 테이블을 리스트가 아닌 dictionary 구조를 사용할 수도 있다.

6. 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래걸린다? -> 다이나믹 프로그래밍 생각
7. 일단 재귀 함수로 구현해놓고 메모이제이션으로 바꾸는 것도 좋은 전략

# 9장(최단 경로)

최단 경로 알고리즘 유형에는 다양한 종류가 있는데, 상황에 맞는 효율적인 알고리즘은 이미 정립되어 있다.
1. 한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우
2. 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우

알고리즘 종류 -> 빅데이터 처리 및 응용 수업시간에 다루었으니 아이패드 메모장 확인
1. 다익스트라 최단경로
2. 플로이드 워셜 알고리즘
3. 벨만 포드 알고리즘 

그리디 알고리즘 및 다이나믹 프로그래밍의 알고리즘의 한 유형일뿐. 

## 다익스트라 최단 경로 알고리즘
- 특정 노드에서 출발해서 다른 노드로 가는 모든 최단 경로를 구해주는 알고리즘
- '음의 간선'이 없을 떄 작동
1. 출발 노드 설정
2. 최단 거리 테이블 초기화
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신
5. 3-4번을 반복

**다익스트라 최단 경로 알고리즘 힙(heap) 구조를 이용하여 구현**
- 힙 : 우선순위 큐. (정렬 기준, 물건)으로 만들 것.
- import heapq
